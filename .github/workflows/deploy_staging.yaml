name: Staging Deployment

on:
  push:
    branches:
      - staging
  workflow_dispatch:

jobs:
  lint:
    name: Run Ruff Linter
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # <-- Corrected syntax

      - name: Set up Python
        uses: actions/setup-python@v5 # <-- Corrected syntax
        with:
          python-version: '3.12'

      - name: Install Ruff
        run: pip install ruff

      - name: Run Ruff linter
        run: ruff check .

  deploy:
    name: Deploy to Staging - ${{ matrix.server.name }}
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        server:
          # Define all servers here. Only update this list when adding new servers.
          - name: EC2-Server-1
            host_secret: EC2_HOST_1 # Name of the secret holding the Hostname/IP
            key_secret: EC2_SSH_PRIVATE_KEY_1 # Name of the secret holding the Private Key
          - name: EC2-Server-2
            host_secret: EC2_HOST_2
            key_secret: EC2_SSH_PRIVATE_KEY_2
          - name: EC2-Server-3
            host_secret: EC2_HOST_3
            key_secret: EC2_SSH_PRIVATE_KEY_3
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # <-- Corrected syntax

      - name: Setup SSH and Get Credentials (Dynamic Secret Access)
        id: setup
        env:
          # Shared secrets (same for all servers)
          SSH_USER: ${{ secrets.EC2_USERNAME }}
          APP_DIR: ${{ secrets.APP_DIRECTORY }}
          
          # Dynamically look up the secret value based on the key name in the matrix
          SSH_KEY: ${{ secrets[matrix.server.key_secret] }}
          SSH_HOST: ${{ secrets[matrix.server.host_secret] }}
          
        run: |
          mkdir -p ~/.ssh
          
          # Use the dynamically fetched SSH_KEY
          echo "${{ env.SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Use the dynamically fetched SSH_HOST
          ssh-keyscan -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Set outputs for subsequent steps
          echo "ssh_host=${{ env.SSH_HOST }}" >> $GITHUB_OUTPUT
          echo "ssh_user=${{ env.SSH_USER }}" >> $GITHUB_OUTPUT
          echo "app_dir=${{ env.APP_DIR }}" >> $GITHUB_OUTPUT

      - name: Stop Application on ${{ matrix.server.name }}
        run: |
          # The entire run command is wrapped in a single string for PowerShell execution via SSH
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${{ steps.setup.outputs.ssh_user }}@${{ steps.setup.outputs.ssh_host }}" \
            "powershell -Command \"\$ErrorActionPreference = 'Stop'; New-Item -ItemType File -Path '${{ steps.setup.outputs.app_dir }}\logs\STOP' -Force -ErrorAction SilentlyContinue | Out-Null; \$pythonProcess = Get-Process -Name python -ErrorAction SilentlyContinue; if (\$pythonProcess) { Write-Host 'Python process found. Stopping...'; Stop-Process -Name python -Force; Write-Host 'Python process stopped successfully.' } else { Write-Error 'ERROR: Python process is not running. Cannot stop a process that does not exist.'; exit 1 }\""

      - name: Pull Latest Code on ${{ matrix.server.name }}
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${{ steps.setup.outputs.ssh_user }}@${{ steps.setup.outputs.ssh_host }}" \
            "powershell -Command \"if (-not (Test-Path '${{ steps.setup.outputs.app_dir }}')) { Write-Error \"Application directory does not exist: ${{ steps.setup.outputs.app_dir }}\"; exit 1 }; cd '${{ steps.setup.outputs.app_dir }}'; \$oldErrorAction = \$ErrorActionPreference; \$ErrorActionPreference = 'SilentlyContinue'; \$null = git rev-parse --git-dir 2>&1; \$isGitRepo = (\$LASTEXITCODE -eq 0); \$ErrorActionPreference = \$oldErrorAction; if (-not \$isGitRepo) { Write-Error \"ERROR: Not a git repository. Directory '${{ steps.setup.outputs.app_dir }}' exists but is not a git repository. Please ensure the repository has been cloned to this location.\"; exit 1 }; \$ErrorActionPreference = 'Stop'; git pull origin staging; if (\$LASTEXITCODE -ne 0) { Write-Error \"Git pull failed with exit code \$LASTEXITCODE\"; exit \$LASTEXITCODE }\""

      - name: Restart Application on ${{ matrix.server.name }}
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${{ steps.setup.outputs.ssh_user }}@${{ steps.setup.outputs.ssh_host }}" \
            "powershell -Command \"\$ErrorActionPreference = 'Stop'; schtasks /run /tn 'BrowserAutomationStartup'; if (\$LASTEXITCODE -ne 0) { Write-Error \"Failed to restart application. Scheduled task returned exit code \$LASTEXITCODE\"; exit \$LASTEXITCODE }\""

      - name: Verify Deployment on ${{ matrix.server.name }}
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${{ steps.setup.outputs.ssh_user }}@${{ steps.setup.outputs.ssh_host }}" \
            "powershell -Command \"if (-not (Test-Path '${{ steps.setup.outputs.app_dir }}')) { Write-Error \"Application directory does not exist: ${{ steps.setup.outputs.app_dir }}\"; exit 1 }; cd '${{ steps.setup.outputs.app_dir }}'; \$oldErrorAction = \$ErrorActionPreference; \$ErrorActionPreference = 'SilentlyContinue'; \$null = git rev-parse --git-dir 2>&1; \$isGitRepo = (\$LASTEXITCODE -eq 0); \$ErrorActionPreference = \$oldErrorAction; if (-not \$isGitRepo) { Write-Error \"ERROR: Not a git repository. Directory '${{ steps.setup.outputs.app_dir }}' exists but is not a git repository.\"; exit 1 }; \$ErrorActionPreference = 'Stop'; git log -1 --oneline; if (\$LASTEXITCODE -ne 0) { Write-Error \"Failed to verify deployment. Git log returned exit code \$LASTEXITCODE\"; exit \$LASTEXITCODE }\""

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/deploy_key