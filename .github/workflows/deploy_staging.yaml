name: Staging Deployment

on:
  push:
    branches:
      - staging
  workflow_dispatch:

jobs:
  lint:
    name: Run Ruff Linter
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Ruff
        run: pip install ruff

      - name: Run Ruff linter
        run: ruff check .

  deploy:
    name: Deploy to Staging - ${{ matrix.server.name }}
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        server:
          # Define all servers here. Only update this list when adding new servers.
          - name: EC2-Server-1
            host_secret: EC2_HOST_1 # Name of the secret holding the Hostname/IP
            key_secret: EC2_SSH_PRIVATE_KEY_1 # Name of the secret holding the Private Key
          # - name: EC2-Server-2
          #   host_secret: EC2_HOST_2
          #   key_secret: EC2_SSH_PRIVATE_KEY_2
          # - name: EC2-Server-3
          #   host_secret: EC2_HOST_3
          #   key_secret: EC2_SSH_PRIVATE_KEY_3
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH and Get Credentials (Dynamic Secret Access)
        id: setup
        env:
          # Shared secrets (same for all servers)
          SSH_USER: ${{ secrets.EC2_USERNAME }}
          APP_DIR: ${{ secrets.APP_DIRECTORY }}
          
          # Dynamically look up the secret value based on the key name in the matrix
          SSH_KEY: ${{ secrets[matrix.server.key_secret] }}
          SSH_HOST: ${{ secrets[matrix.server.host_secret] }}
          
        run: |
          mkdir -p ~/.ssh
          
          # Use the dynamically fetched SSH_KEY
          echo "${{ env.SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Use the dynamically fetched SSH_HOST
          ssh-keyscan -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Set outputs for subsequent steps
          echo "ssh_host=${{ env.SSH_HOST }}" >> $GITHUB_OUTPUT
          echo "ssh_user=${{ env.SSH_USER }}" >> $GITHUB_OUTPUT
          echo "app_dir=${{ env.APP_DIR }}" >> $GITHUB_OUTPUT

      - name: Stop Application on ${{ matrix.server.name }}
        # MODIFIED: Now fails the job if the Python process is not found.
        run: |
          echo "Stopping existing application process on server ${{ matrix.server.name }} if running..."
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
              \$ErrorActionPreference = 'Stop'; 
              \$pythonProcess = Get-Process -Name python -ErrorAction SilentlyContinue; 
              
              if (\$pythonProcess) { 
                Write-Host 'Python process found. Stopping...' -ForegroundColor Yellow; 
                Stop-Process -Name python -Force; 
                Write-Host 'Python process stopped successfully.' -ForegroundColor Green 
              } else { 
                # If process is not found, write error and exit with code 1 (failure)
                Write-Error 'ERROR: Python process was NOT found running. Halting deployment.' -ForegroundColor Red;
                exit 1;
              }
            \""

      - name: Pull Latest Code on ${{ matrix.server.name }}
        # Logging uses Write-Host for clearer visibility
        run: |
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"
          
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
              \$GitExe = 'C:\Program Files\Git\bin\git.exe';
              
              if (-not (Test-Path '${APP_DIR}')) { Write-Error \"Application directory does not exist: ${APP_DIR}\"; exit 1 }; 
              cd '${APP_DIR}'; 
              
              \$oldErrorAction = \$ErrorActionPreference; 
              \$ErrorActionPreference = 'SilentlyContinue'; 
              & \"\$GitExe\" rev-parse --git-dir 2>&1 | Out-String; 
              \$isGitRepo = (\$LASTEXITCODE -eq 0); 
              \$ErrorActionPreference = \$oldErrorAction; 
              
              if (-not \$isGitRepo) { 
                Write-Error \"ERROR: Not a git repository. Directory '${APP_DIR}' exists but is not a git repository. Please ensure the repository has been cloned to this location.\"; 
                exit 1 
              }; 
              
              \$ErrorActionPreference = 'Stop'; 
              Write-Host 'Pulling latest code from staging branch...' -ForegroundColor Yellow; 
              & \"\$GitExe\" pull origin staging; 
              
              if (\$LASTEXITCODE -ne 0) { 
                Write-Error \"Git pull failed with exit code \$LASTEXITCODE\"; 
                exit \$LASTEXITCODE 
              } else { 
                Write-Host 'Code pull successful.' -ForegroundColor Green
              }
            \""

      - name: Start Application (Detached)
        # Separate step to start the process without polling (runs quick)
        id: start
        run: |
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"
          
          echo "Attempting DIRECT, NON-BLOCKING Application START via Start-Process..."
          
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
            \$ErrorActionPreference = 'Stop';
            \$PythonPath = 'python'; 
            \$ScriptPath = '${APP_DIR}\main.py';
            
            # Start the process detached.
            Start-Process -FilePath \$PythonPath -ArgumentList \$ScriptPath -WorkingDirectory '${APP_DIR}' -NoNewWindow | Out-Null;
            
            Write-Host 'Application start command sent.' -ForegroundColor Cyan;
            \""
          echo "Application start command successfully executed on remote server."

      - name: Verify Application Process (Real-time Polling)
        # Fixes from last turn included: use robust 'tasklist' and '|| true' for retry logic.
        run: |
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          MAX_ATTEMPTS=5   # Max wait time of 5 * 30 = 150 seconds
          WAIT_SECONDS=30
          PROCESS_NAME='python'

          echo "Starting real-time polling for process '${PROCESS_NAME}'..."
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
              echo "[POLL $i/$MAX_ATTEMPTS] Waiting $WAIT_SECONDS seconds... Checking for process '${PROCESS_NAME}'..."
              sleep $WAIT_SECONDS

              # Use 'tasklist' and 'find' in a simple CMD command, which is more reliable than PowerShell for this simple check.
              # '|| true' ensures the loop continues even if the SSH command fails to connect or run the command.
              CHECK_RESULT=$(ssh -i ~/.ssh/deploy_key \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=~/.ssh/known_hosts \
                "${USER}@${HOST}" \
                "cmd.exe /c \"tasklist /nh /fi \"IMAGENAME eq ${PROCESS_NAME}.exe\" 2>&1\"" || true)

              # Check if the output contains the process name (meaning it's running)
              if echo "$CHECK_RESULT" | grep -i "${PROCESS_NAME}.exe"; then
                  echo "✅ Process '${PROCESS_NAME}' found running on the VM."
                  exit 0 # Success, exit the step successfully
              fi
          done

          echo "❌ TIMEOUT: Application process '${PROCESS_NAME}' not found running after $(($MAX_ATTEMPTS * $WAIT_SECONDS)) seconds."
          exit 1

      - name: Verify Deployment Commit Hash on ${{ matrix.server.name }}
        # Logging uses Write-Host for clearer visibility
        run: |
          
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"

          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
              \$GitExe = 'C:\Program Files\Git\bin\git.exe';
              
              if (-not (Test-Path '${APP_DIR}')) { 
                Write-Error \"Application directory does not exist: ${APP_DIR}\"; 
                exit 1 
              }; 
              
              cd '${APP_DIR}'; 
              
              \$oldErrorAction = \$ErrorActionPreference; 
              \$ErrorActionPreference = 'SilentlyContinue'; 
              & \"\$GitExe\" rev-parse --git-dir 2>&1 | Out-String; 
              \$isGitRepo = (\$LASTEXITCODE -eq 0); 
              \$ErrorActionPreference = \$oldErrorAction; 
              
              if (-not \$isGitRepo) { 
                Write-Error \"ERROR: Not a git repository. Directory '${APP_DIR}' exists but is not a git repository. Please ensure the repository has been cloned to this location.\"; 
                exit 1 
              }; 
              
              \$ErrorActionPreference = 'Stop'; 
              Write-Host 'Current Commit Hash: ' -ForegroundColor Cyan; 
              & \"\$GitExe\" log -1 --oneline | Out-String; 
              
              if (\$LASTEXITCODE -ne 0) { 
                Write-Error \"❌ Failed to verify deployment. Git log returned exit code \$LASTEXITCODE\"; 
                exit \$LASTEXITCODE 
              }
            \""

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/deploy_key