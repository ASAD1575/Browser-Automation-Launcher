name: Staging Deployment

on:
  push:
    branches:
      - staging
  workflow_dispatch:

jobs:
  lint:
    name: Run Ruff Linter
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Ruff
        run: pip install ruff

      - name: Run Ruff linter
        run: ruff check .

  deploy:
    name: Deploy to Staging - ${{ matrix.server.name }}
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        server:
          # Define all servers here. Only update this list when adding new servers.
          - name: EC2-Server-1
            host_secret: EC2_HOST_1 # Name of the secret holding the Hostname/IP
            key_secret: EC2_SSH_PRIVATE_KEY_1 # Name of the secret holding the Private Key
          # - name: EC2-Server-2
          #   host_secret: EC2_HOST_2
          #   key_secret: EC2_SSH_PRIVATE_KEY_2
          # - name: EC2-Server-3
          #   host_secret: EC2_HOST_3
          #   key_secret: EC2_SSH_PRIVATE_KEY_3
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH and Get Credentials (Dynamic Secret Access)
        id: setup
        env:
          # Shared secrets (same for all servers)
          SSH_USER: ${{ secrets.EC2_USERNAME }}
          APP_DIR: ${{ secrets.APP_DIRECTORY }}
          
          # Dynamically look up the secret value based on the key name in the matrix
          SSH_KEY: ${{ secrets[matrix.server.key_secret] }}
          SSH_HOST: ${{ secrets[matrix.server.host_secret] }}
          
        run: |
          mkdir -p ~/.ssh
          
          # Use the dynamically fetched SSH_KEY
          echo "${{ env.SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Use the dynamically fetched SSH_HOST
          ssh-keyscan -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Set outputs for subsequent steps
          echo "ssh_host=${{ env.SSH_HOST }}" >> $GITHUB_OUTPUT
          echo "ssh_user=${{ env.SSH_USER }}" >> $GITHUB_OUTPUT
          echo "app_dir=${{ env.APP_DIR }}" >> $GITHUB_OUTPUT

      # - name: Stop Application on ${{ matrix.server.name }}
      #   # This step is critical: it kills the old process before we start a new one.
      #   run: |
      #     echo "Stopping existing application process on server ${{ matrix.server.name }} if running..."
      #     # Use the setup outputs for connection details
      #     USER="${{ steps.setup.outputs.ssh_user }}"
      #     HOST="${{ steps.setup.outputs.ssh_host }}"
      #     APP_DIR="${{ steps.setup.outputs.app_dir }}"
          
      #     ssh -i ~/.ssh/deploy_key \
      #       -o StrictHostKeyChecking=no \
      #       -o UserKnownHostsFile=~/.ssh/known_hosts \
      #       "${USER}@${HOST}" \
      #       "powershell -Command \"\$ErrorActionPreference = 'Stop'; \$pythonProcess = Get-Process -Name python -ErrorAction SilentlyContinue; if (\$pythonProcess) { Write-Warning 'Python process found. Stopping...'; New-Item -ItemType File -Path '${{ steps.setup.outputs.app_dir }}\logs\STOP'; Stop-Process -Name python -Force; Write-Warning 'Python process stopped successfully.' } else { Write-Warning 'INFO: Python process was not running.' }\""

      # - name: Pull Latest Code on ${{ matrix.server.name }}
      #   run: |
      #     ssh -i ~/.ssh/deploy_key \
      #       -o StrictHostKeyChecking=no \
      #       -o UserKnownHostsFile=~/.ssh/known_hosts \
      #       "${{ steps.setup.outputs.ssh_user }}@${{ steps.setup.outputs.ssh_host }}" \
      #       "powershell -Command \"if (-not (Test-Path '${{ steps.setup.outputs.app_dir }}')) { Write-Error \"Application directory does not exist: ${{ steps.setup.outputs.app_dir }}\"; exit 1 }; cd '${{ steps.setup.outputs.app_dir }}'; \$oldErrorAction = \$ErrorActionPreference; \$ErrorActionPreference = 'SilentlyContinue'; \$null = git rev-parse --git-dir 2>&1; \$isGitRepo = (\$LASTEXITCODE -eq 0); \$ErrorActionPreference = \$oldErrorAction; if (-not \$isGitRepo) { Write-Error \"ERROR: Not a git repository. Directory '${{ steps.setup.outputs.app_dir }}' exists but is not a git repository. Please ensure the repository has been cloned to this location.\"; exit 1 }; \$ErrorActionPreference = 'Stop'; git pull origin staging; if (\$LASTEXITCODE -ne 0) { Write-Error \"Git pull failed with exit code \$LASTEXITCODE\"; exit \$LASTEXITCODE }\""

      - name: Start Application (Run PowerShell Script Detached)
        # UPDATED: Uses the APP_DIR variable to construct the full path to the script.
        id: start
        run: |
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"
          
          # Construct the path using APP_DIR
          SCRIPT_PATH="${APP_DIR}\scripts\simple_startup.ps1" 
          
          echo "Attempting to run PowerShell script '${SCRIPT_PATH}' in a detached process..."
          
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
              \$ErrorActionPreference = 'Stop';
              \$ScriptPath = '${SCRIPT_PATH}';
              
              if (-not (Test-Path \$ScriptPath)) {
                Write-Error \"❌ ERROR: Script not found at: \$ScriptPath\" -ForegroundColor Red;
                exit 1;
              }

              # Use Start-Process to launch a new, detached PowerShell instance running the script.
              Write-Host 'Launching new PowerShell process for script execution...' -ForegroundColor Cyan;
              Start-Process powershell -ArgumentList '-NoProfile', '-File', \$ScriptPath;
              
              Write-Host 'Script launch command sent. SSH session exiting now.' -ForegroundColor Green;
            \""
          echo "Remote script execution command successfully initiated."

      # - name: Display Startup Logs on ${{ matrix.server.name }}
      #   run: |
      #     echo "Waiting 5 seconds for application to initialize and write logs..."
      #     sleep 5 # Give the server time to fully start and write its "running" message
          
      #     USER="${{ steps.setup.outputs.ssh_user }}"
      #     HOST="${{ steps.setup.outputs.ssh_host }}"
      #     APP_DIR="${{ steps.setup.outputs.app_dir }}"
          
      #     echo "Fetching last 20 lines of application logs..."
          
      #     ssh -i ~/.ssh/deploy_key \
      #       -o StrictHostKeyChecking=no \
      #       -o UserKnownHostsFile=~/.ssh/known_hosts \
      #       "${USER}@${HOST}" \
      #       "powershell -Command \"
      #         \$LogFile = '${APP_DIR}\app_startup.log';
      #         if (Test-Path \$LogFile) {
      #           Write-Host '--- START OF APPLICATION LOG ---' -ForegroundColor Blue
      #           Get-Content \$LogFile -Tail 20
      #           Write-Host '--- END OF APPLICATION LOG ---' -ForegroundColor Blue
      #         } else {
      #           Write-Warning 'WARNING: Log file not found at \$LogFile.' -ForegroundColor Yellow
      #         }
      #       \""
      #     echo "Log display complete."


      - name: Verify Application Process (Real-time Polling)
        # Fixes from last turn included: use robust 'tasklist' and '|| true' for retry logic.
        run: |
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          MAX_ATTEMPTS=5   # Max wait time of 5 * 30 = 150 seconds
          WAIT_SECONDS=30
          PROCESS_NAME='python'

          echo "Starting real-time polling for process '${PROCESS_NAME}'..."
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
              echo "[POLL $i/$MAX_ATTEMPTS] Waiting $WAIT_SECONDS seconds... Checking for process '${PROCESS_NAME}'"
              sleep $WAIT_SECONDS

              # Use 'tasklist' and 'find' in a simple CMD command, which is more reliable than PowerShell for this simple check.
              # '|| true' ensures the loop continues even if the SSH command fails to connect or run the command.
              CHECK_RESULT=$(ssh -i ~/.ssh/deploy_key \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=~/.ssh/known_hosts \
                "${USER}@${HOST}" \
                "cmd.exe /c \"tasklist /nh /fi \"IMAGENAME eq ${PROCESS_NAME}.exe\" 2>&1\"" || true)

              # Check if the output contains the process name (meaning it's running)
              if echo "$CHECK_RESULT" | grep -i "${PROCESS_NAME}.exe"; then
                  echo "✅ Process '${PROCESS_NAME}' found running on the VM."
                  exit 0 # Success, exit the step successfully
              fi
          done

          echo "❌ TIMEOUT: Application process '${PROCESS_NAME}' not found running after $(($MAX_ATTEMPTS * $WAIT_SECONDS)) seconds."
          exit 1

      - name: Verify Deployment Commit Hash on ${{ matrix.server.name }}
        # Logging uses Write-Host for clearer visibility
        run: |
          
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"

          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
              \$GitExe = 'C:\Program Files\Git\bin\git.exe';
              
              if (-not (Test-Path '${APP_DIR}')) { 
                Write-Error \"Application directory does not exist: ${APP_DIR}\"; 
                exit 1 
              }; 
              
              cd '${APP_DIR}'; 
              
              \$oldErrorAction = \$ErrorActionPreference; 
              \$ErrorActionPreference = 'SilentlyContinue'; 
              & \"\$GitExe\" rev-parse --git-dir 2>&1 | Out-String; 
              \$isGitRepo = (\$LASTEXITCODE -eq 0); 
              \$ErrorActionPreference = \$oldErrorAction; 
              
              if (-not \$isGitRepo) { 
                Write-Error \"ERROR: Not a git repository. Directory '${APP_DIR}' exists but is not a git repository. Please ensure the repository has been cloned to this location.\"; 
                exit 1 
              }; 
              
              \$ErrorActionPreference = 'Stop'; 
              Write-Host 'Current Commit Hash: ' -ForegroundColor Cyan; 
              & \"\$GitExe\" log -1 --oneline | Out-String; 
              
              if (\$LASTEXITCODE -ne 0) { 
                Write-Error \"❌ Failed to verify deployment. Git log returned exit code \$LASTEXITCODE\"; 
                exit \$LASTEXITCODE 
              }
            \""

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/deploy_key