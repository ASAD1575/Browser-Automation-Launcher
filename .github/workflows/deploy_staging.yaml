name: Staging Deployment

on:
  push:
    branches:
      - staging
  workflow_dispatch:

jobs:
  lint:
    name: Run Ruff Linter
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Ruff
        run: pip install ruff

      - name: Run Ruff linter
        run: ruff check .

  deploy:
    name: Deploy to Staging - ${{ matrix.server.name }}
    needs: lint
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        server:
          # Define all servers here. Only update this list when adding new servers.
          - name: EC2-Server-1
            host_secret: EC2_HOST_1 # Name of the secret holding the Hostname/IP
            key_secret: EC2_SSH_PRIVATE_KEY_1 # Name of the secret holding the Private Key
          # - name: EC2-Server-2
          #   host_secret: EC2_HOST_2
          #   key_secret: EC2_SSH_PRIVATE_KEY_2
          # - name: EC2-Server-3
          #   host_secret: EC2_HOST_3
          #   key_secret: EC2_SSH_PRIVATE_KEY_3
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH and Get Credentials (Dynamic Secret Access)
        id: setup
        env:
          # Shared secrets (same for all servers)
          SSH_USER: ${{ secrets.EC2_USERNAME }}
          APP_DIR: ${{ secrets.APP_DIRECTORY }}
          
          # Dynamically look up the secret value based on the key name in the matrix
          SSH_KEY: ${{ secrets[matrix.server.key_secret] }}
          SSH_HOST: ${{ secrets[matrix.server.host_secret] }}
          
        run: |
          mkdir -p ~/.ssh
          
          # Use the dynamically fetched SSH_KEY
          echo "${{ env.SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Use the dynamically fetched SSH_HOST
          ssh-keyscan -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Set outputs for subsequent steps
          echo "ssh_host=${{ env.SSH_HOST }}" >> $GITHUB_OUTPUT
          echo "ssh_user=${{ env.SSH_USER }}" >> $GITHUB_OUTPUT
          echo "app_dir=${{ env.APP_DIR }}" >> $GITHUB_OUTPUT

      - name: Stop Application on ${{ matrix.server.name }}
        run: |
          # Use the setup outputs for connection details
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"
          
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"\$ErrorActionPreference = 'Stop'; New-Item -ItemType File -Path '${APP_DIR}\logs\STOP' -Force -ErrorAction SilentlyContinue | Out-Null; \$pythonProcess = Get-Process -Name python -ErrorAction SilentlyContinue; if (\$pythonProcess) { Write-Warning 'Python process found. Stopping...'; Stop-Process -Name python -Force; Write-Warning 'Python process stopped successfully.' } else { Write-Warning 'INFO: Python process was not running.' }\""

      - name: Pull Latest Code on ${{ matrix.server.name }}
        run: |
          # Use the setup outputs for connection details
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"
          
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"if (-not (Test-Path '${APP_DIR}')) { Write-Error \"Application directory does not exist: ${APP_DIR}\"; exit 1 }; cd '${APP_DIR}'; \$oldErrorAction = \$ErrorActionPreference; \$ErrorActionPreference = 'SilentlyContinue'; \$null = git rev-parse --git-dir 2>&1; \$isGitRepo = (\$LASTEXITCODE -eq 0); \$ErrorActionPreference = \$oldErrorAction; if (-not \$isGitRepo) { Write-Error \"ERROR: Not a git repository. Directory '${APP_DIR}' exists but is not a git repository. Please ensure the repository has been cloned to this location.\"; exit 1 }; \$ErrorActionPreference = 'Stop'; Write-Warning 'Pulling latest code from staging branch...'; git pull origin staging; if (\$LASTEXITCODE -ne 0) { Write-Error \"Git pull failed with exit code \$LASTEXITCODE\"; exit \$LASTEXITCODE } else { Write-Warning 'Code pull successful.' }\""

      - name: Restart Application and Verify Success on ${{ matrix.server.name }}
        # *** ROBUSTNESS FIX: Polling for 'Last Run Result' (Exit Code 0) ***
        run: |
          # Use the setup outputs for connection details
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"

          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
            \$ErrorActionPreference = 'Stop';
            \$TaskName = 'BrowserAutomationStartup';
            \$MaxAttempts = 10; # Max wait time of 10 * 5 = 50 seconds
            \$WaitSeconds = 5;

            Write-Warning '--- Attempting Robust Scheduled Task RERUN (Start/Stop) ---';
            
            # 1. Query and STOP if running
            Write-Warning 'Querying task status...';
            \$QueryOutput = schtasks /query /tn \$TaskName /fo LIST /v 2>&1 | Out-String; 
            if (\$QueryOutput -match 'State:\\s+Running') {
                Write-Warning \"Task '\$TaskName' is RUNNING. Stopping it...\";
                schtasks /end /tn \$TaskName 2>&1 | Out-String; 
                if (\$LASTEXITCODE -ne 0) {
                    Write-Error \"❌ Failed to STOP task '\$TaskName'. Exit code: \$LASTEXITCODE\"; 
                    exit 1;
                }
                Write-Warning 'Task stopped successfully. Waiting 10 seconds for process teardown...';
                Start-Sleep -Seconds 10; 
            }

            # 2. Run the task
            Write-Warning \"Attempting to run scheduled task: \$TaskName...\";
            schtasks /run /tn \$TaskName 2>&1 | Out-String;

            if (\$LASTEXITCODE -ne 0) {
                Write-Error \"❌ Failed to TRIGGER scheduled task '\$TaskName'. Schtasks returned exit code \$LASTEXITCODE\";
                exit 1;
            }
            Write-Warning 'Scheduled task trigger command accepted. Starting polling for execution status...';
            
            # 3. Polling loop to verify Last Run Result (0 is success)
            for (\$i = 1; \$i -le \$MaxAttempts; \$i++) {
                Write-Warning \"[POLL \`$i/\`$MaxAttempts] Waiting \`$WaitSeconds seconds...\";
                Start-Sleep -Seconds \$WaitSeconds;
                
                \$TaskInfo = schtasks /query /tn \$TaskName /fo LIST /v 2>&1 | Out-String;
                
                \$LastRunResult = \$null;
                if (\$TaskInfo -match 'Last Run Result:\\s+(\\d+)') {
                    \$LastRunResult = [int]\$Matches[1];
                }

                if (\$LastRunResult -eq 0) {
                    Write-Warning \"✅ Task execution successful! Last Run Result is 0.\";
                    exit 0; # Success
                } elseif (\$LastRunResult -ne \$null -and \$LastRunResult -ne 1 -and \$LastRunResult -ne 2) {
                    # 1 and 2 are typically 'Running' or 'Task not yet run' codes, so other non-zero is a failure
                    Write-Error \"❌ TASK FAILED: Last Run Result is '\$LastRunResult'. Check the Task Scheduler history on the VM for details.\";
                    exit 1;
                }
            }

            Write-Error \"❌ TIMEOUT: Scheduled task did not report successful completion (Last Run Result 0) after \$((\$MaxAttempts * \$WaitSeconds)) seconds.\";
            exit 1;
            \""

      - name: Verify Application Running Status
        # Simplified verification step as the restart step now handles success confirmation
        run: |
          # Use the setup outputs for connection details
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"

          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}" \
            "powershell -Command \"
            \$ErrorActionPreference = 'Stop';
            \$TaskName = 'BrowserAutomationStartup';

            Write-Warning '--- Deployment Verification by Scheduled Task Status ---';
            
            \$TaskInfo = schtasks /query /tn \$TaskName /fo LIST /v 2>\$null;
            \$CurrentState = 'Unknown';
            \$LastRunResult = 'Unknown';

            if (\$TaskInfo -match 'State:\\s+(\\w+)') {
                \$CurrentState = \$Matches[1];
            }
            if (\$TaskInfo -match 'Last Run Result:\\s+(\\d+)') {
                \$LastRunResult = \$Matches[1];
            }
            
            Write-Warning \"[VERIFY STATUS] Final task state reported as: \$CurrentState\";
            Write-Warning \"[VERIFY RESULT] Last Run Result: \$LastRunResult\";
            
            if (\$CurrentState -eq 'Running') {
                Write-Warning '✅ Application process is Running according to the scheduler.';
            } elseif (\$LastRunResult -eq '0') {
                Write-Warning '✅ Task successfully completed (Result 0). Assuming application is running as designed.';
            } else {
                Write-Error \"❌ WARNING: Task is not Running and Last Run Result was not 0. Investigate VM for process errors.\";
                exit 1;
            }
            \""

      - name: Verify Deployment Commit Hash on ${{ matrix.server.name }}
        run: |
          # Use the setup outputs for connection details
          USER="${{ steps.setup.outputs.ssh_user }}"
          HOST="${{ steps.setup.outputs.ssh_host }}"
          APP_DIR="${{ steps.setup.outputs.app_dir }}"

          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${USER}@${HOST}"
            "powershell -Command \"if (-not (Test-Path '${APP_DIR}')) { Write-Error \"Application directory does not exist: ${APP_DIR}\"; exit 1 }; cd '${APP_DIR}'; \$oldErrorAction = \$ErrorActionPreference; \$ErrorActionPreference = 'SilentlyContinue'; \$null = git rev-parse --git-dir 2>&1; \$isGitRepo = (\$LASTEXITCODE -eq 0); \$ErrorActionPreference = \$oldErrorAction; if (-not \$isGitRepo) { Write-Error \"ERROR: Not a git repository. Directory '${APP_DIR}' exists but is not a git repository. Please ensure the repository has been cloned to this location.\"; exit 1 }; \$ErrorActionPreference = 'Stop'; Write-Warning 'Current Commit Hash: '; git log -1 --oneline | Out-String; if (\$LASTEXITCODE -ne 0) { Write-Error \"Failed to verify deployment. Git log returned exit code \$LASTEXITCODE\"; exit \$LASTEXITCODE }\""

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/deploy_key