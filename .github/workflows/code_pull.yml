name: Staging Deployment

on:
  push:
    branches:
      - staging
  workflow_dispatch:
    inputs:
      command_to_run:
        description: 'PowerShell script to execute on each Windows instance (semicolon-separated commands)'
        required: false
        default: |
          cd C:\Users\ticketboat\Documents\Applications\browser-automation-launcher; New-Item -ItemType File -Path "C:\Users\ticketboat\Documents\Applications\browser-automation-launcher\logs\STOP" -Force; Stop-Process -Name python -Force -ErrorAction SilentlyContinue; git pull origin main; schtasks /run /tn "BrowserAutomationStartup"

jobs:
  deploy-staging:
    # Allow both push events and manual workflow dispatch
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/staging') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    
    env:
      # Use GitHub variable or fallback to default names
      INSTANCE_NAMES: "${{ vars.STAGING_INSTANCE_NAMES || 'Browser-Automation-Launcher-1-Dev' }}"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::375299695019:role/GitHubActionsTerraformRole
          aws-region: us-east-1

      - name: Install or Upgrade AWS CLI v2
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip curl
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -o awscliv2.zip
          sudo ./aws/install --update
          aws --version

      - name: Install jq (for JSON parsing)
        run: sudo apt-get update && sudo apt-get install -y jq
        
      - name: Lookup Instance IDs by Name
        id: instance_lookup
        run: |
          # Convert comma-separated names into a filter string suitable for the AWS CLI
          NAMES_ARRAY=$(echo "$INSTANCE_NAMES" | tr ',' ' ')
          echo "Targeting names: $NAMES_ARRAY"
          
          # Use describe-instances to filter by the 'Name' tag and output only the Instance IDs
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${NAMES_ARRAY}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text)
            
          if [ -z "$INSTANCE_IDS" ]; then
            echo "::error::No running instances found with the names specified: $INSTANCE_NAMES"
            exit 1
          fi
          
          # Store the found IDs as comma-separated string for the next step to consume
          CSV_IDS=$(echo $INSTANCE_IDS | tr '\t' ',')
          
          echo "Found Instance IDs: $CSV_IDS"
          echo "instance_ids=$CSV_IDS" >> $GITHUB_OUTPUT

      - name: Verify SSM Connectivity
        run: |
          echo "Verifying SSM connectivity for all instances..."
          IFS=',' read -ra IDS <<< "${{ steps.instance_lookup.outputs.instance_ids }}"
          for INSTANCE_ID in "${IDS[@]}"; do
            STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
              --query 'InstanceInformationList[0].PingStatus' \
              --output text 2>/dev/null || echo "Unknown")
            
            if [ "$STATUS" != "Online" ]; then
              echo "::warning::Instance $INSTANCE_ID is not SSM-ready (status: $STATUS)"
            else
              echo "✓ Instance $INSTANCE_ID is SSM-ready"
            fi
          done
        
      - name: Execute Command on All Found Instances (PowerShell Script)
        id: execute_command
        run: |
          # Determine command to run: use input if provided, otherwise use default
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ github.event.inputs.command_to_run }}" ]; then
            COMMAND_SCRIPT="${{ github.event.inputs.command_to_run }}"
          else
            # Default command for push events
            COMMAND_SCRIPT='cd C:\Users\ticketboat\Documents\Applications\browser-automation-launcher; New-Item -ItemType File -Path "C:\Users\ticketboat\Documents\Applications\browser-automation-launcher\logs\STOP" -Force; Stop-Process -Name python -Force -ErrorAction SilentlyContinue; git pull origin staging; schtasks /run /tn "BrowserAutomationStartup"'
          fi
          
          echo "Executing script on instances:"
          echo "$COMMAND_SCRIPT"
          
          # Convert command to JSON array format for SSM
          # Split by semicolon and create JSON array
          COMMAND_JSON=$(echo "$COMMAND_SCRIPT" | jq -R -s 'split(";") | map(gsub("^\\s+|\\s+$"; "")) | map(select(length > 0))')
          
          if [ $? -ne 0 ] || [ -z "$COMMAND_JSON" ]; then
            echo "::error::Failed to convert command to JSON format"
            exit 1
          fi
          
          echo "Command JSON: $COMMAND_JSON"
          
          # Get instance IDs as comma-separated list
          INSTANCE_IDS_CSV="${{ steps.instance_lookup.outputs.instance_ids }}"
          
          echo "Sending command to instances: $INSTANCE_IDS_CSV"
          
          # Create parameters JSON file to avoid shell escaping issues
          PARAMS_JSON=$(jq -n --argjson commands "$COMMAND_JSON" '{commands: $commands}')
          
          echo "Parameters JSON:"
          echo "$PARAMS_JSON" | jq '.'
          
          # Run the command using AWS-RunPowerShellScript document
          # Capture stderr separately to check for actual errors
          COMMAND_RESPONSE=$(aws ssm send-command \
            --instance-ids "$INSTANCE_IDS_CSV" \
            --document-name "AWS-RunPowerShellScript" \
            --parameters "$PARAMS_JSON" \
            --timeout-seconds 3600 \
            --output json 2>ssm_error.log)
          
          SSM_EXIT_CODE=$?
          SSM_ERROR=$(cat ssm_error.log 2>/dev/null || echo "")
          
          # Check if AWS CLI command failed (exit code non-zero)
          if [ $SSM_EXIT_CODE -ne 0 ]; then
            echo "::error::Failed to send SSM command (exit code: $SSM_EXIT_CODE)"
            if [ -n "$SSM_ERROR" ]; then
              echo "Error output: $SSM_ERROR"
            fi
            echo "Response: $COMMAND_RESPONSE"
            exit 1
          fi
          
          # Check if response contains an AWS error (has __type field indicating an error)
          if echo "$COMMAND_RESPONSE" | jq -e '.__type' > /dev/null 2>&1; then
            ERROR_TYPE=$(echo "$COMMAND_RESPONSE" | jq -r '.__type // "Unknown"')
            ERROR_MESSAGE=$(echo "$COMMAND_RESPONSE" | jq -r '.message // .Message // "Unknown error"')
            echo "::error::AWS API Error: $ERROR_TYPE"
            echo "Error Message: $ERROR_MESSAGE"
            echo "Full response: $COMMAND_RESPONSE"
            exit 1
          fi
          
          # Check if response is valid JSON and contains CommandId
          if ! echo "$COMMAND_RESPONSE" | jq -e '.Command.CommandId' > /dev/null 2>&1; then
            echo "::error::Invalid response from SSM (no CommandId found)"
            echo "Response: $COMMAND_RESPONSE"
            exit 1
          fi
          
          COMMAND_ID=$(echo "$COMMAND_RESPONSE" | jq -r '.Command.CommandId')
          
          if [ -z "$COMMAND_ID" ] || [ "$COMMAND_ID" = "null" ]; then
            echo "::error::Failed to extract Command ID from response: $COMMAND_RESPONSE"
            exit 1
          fi
          
          echo "SSM Command ID: $COMMAND_ID"
          echo "Full command response:"
          echo "$COMMAND_RESPONSE" | jq '.'
          
          # Wait a moment for the command to be registered
          echo "Waiting 5 seconds for command to be registered..."
          sleep 5
          
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      - name: Wait for Command Completion
        run: |
          COMMAND_ID="${{ steps.execute_command.outputs.command_id }}"
          
          echo "Waiting for command execution to complete on all instances..."
          echo "Command ID: $COMMAND_ID"
          
          # First, check overall command status
          echo "Checking overall command status..."
          COMMAND_STATUS=$(aws ssm list-commands \
            --command-id "$COMMAND_ID" \
            --query 'Commands[0]' \
            --output json 2>/dev/null)
          
          if [ -n "$COMMAND_STATUS" ] && echo "$COMMAND_STATUS" | jq -e '.CommandId' > /dev/null 2>&1; then
            OVERALL_STATUS=$(echo "$COMMAND_STATUS" | jq -r '.Status // "Unknown"')
            COMPLETED_COUNT=$(echo "$COMMAND_STATUS" | jq -r '.CompletedCount // 0')
            ERROR_COUNT=$(echo "$COMMAND_STATUS" | jq -r '.ErrorCount // 0')
            TARGET_COUNT=$(echo "$COMMAND_STATUS" | jq -r '.TargetCount // 0')
            echo "Overall Command Status: $OVERALL_STATUS"
            echo "Progress: $COMPLETED_COUNT/$TARGET_COUNT completed, $ERROR_COUNT errors"
          fi
          
          IFS=',' read -ra IDS <<< "${{ steps.instance_lookup.outputs.instance_ids }}"
          for INSTANCE_ID in "${IDS[@]}"; do
            echo ""
            echo "=== Waiting for instance $INSTANCE_ID ==="
            MAX_ATTEMPTS=60
            DELAY=10
            ATTEMPT=0
            LAST_STATUS=""
            
            while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
              # Get full invocation details for better debugging
              INVOCATION=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --output json 2>/dev/null)
              
              # Check if we got a valid response (not an AWS error)
              if [ -z "$INVOCATION" ]; then
                echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: No response from SSM, waiting ${DELAY}s..."
                ATTEMPT=$((ATTEMPT + 1))
                if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                  sleep $DELAY
                fi
                continue
              fi
              
              # Check if this is an AWS API error response
              if echo "$INVOCATION" | jq -e '.__type' > /dev/null 2>&1; then
                ERROR_TYPE=$(echo "$INVOCATION" | jq -r '.__type // "Unknown"')
                ERROR_MSG=$(echo "$INVOCATION" | jq -r '.message // .Message // "Unknown error"')
                echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: AWS Error - $ERROR_TYPE: $ERROR_MSG"
                ATTEMPT=$((ATTEMPT + 1))
                if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                  sleep $DELAY
                fi
                continue
              fi
              
              STATUS=$(echo "$INVOCATION" | jq -r '.Status' 2>/dev/null || echo "Unknown")
              STATUS_DETAILS=$(echo "$INVOCATION" | jq -r '.StatusDetails // "N/A"' 2>/dev/null)
              DOCUMENT_NAME=$(echo "$INVOCATION" | jq -r '.DocumentName // "N/A"' 2>/dev/null)
              RESPONSE_CODE=$(echo "$INVOCATION" | jq -r '.ResponseCode // "N/A"' 2>/dev/null)
              
              # Only print status if it changed
              if [ "$STATUS" != "$LAST_STATUS" ]; then
                echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Status=$STATUS, Details=$STATUS_DETAILS, ResponseCode=$RESPONSE_CODE"
                LAST_STATUS="$STATUS"
              fi
              
              if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
                echo "✓ Command completed on instance $INSTANCE_ID with status: $STATUS"
                break
              fi
              
              # If status is still Pending after several attempts, check SSM agent status
              if [ "$STATUS" = "Pending" ] && [ $ATTEMPT -ge 3 ]; then
                SSM_STATUS=$(aws ssm describe-instance-information \
                  --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                  --query 'InstanceInformationList[0].PingStatus' \
                  --output text 2>/dev/null || echo "Unknown")
                
                if [ "$SSM_STATUS" != "Online" ]; then
                  echo "⚠ Warning: Instance SSM agent status is $SSM_STATUS (expected Online)"
                fi
              fi
              
              ATTEMPT=$((ATTEMPT + 1))
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                sleep $DELAY
              fi
            done
            
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              FINAL_INVOCATION=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --output json 2>/dev/null)
              
              if [ -n "$FINAL_INVOCATION" ] && ! echo "$FINAL_INVOCATION" | jq -e '.__type' > /dev/null 2>&1; then
                FINAL_STATUS=$(echo "$FINAL_INVOCATION" | jq -r '.Status' 2>/dev/null || echo "Unknown")
                FINAL_DETAILS=$(echo "$FINAL_INVOCATION" | jq -r '.StatusDetails // "N/A"' 2>/dev/null)
                echo "::warning::Timeout waiting for instance $INSTANCE_ID (final status: $FINAL_STATUS, details: $FINAL_DETAILS)"
                echo "Full invocation details:"
                echo "$FINAL_INVOCATION" | jq '.'
                
                # Additional diagnostics
                echo ""
                echo "=== Diagnostic Information ==="
                echo "Checking SSM agent status..."
                aws ssm describe-instance-information \
                  --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                  --output json | jq '.InstanceInformationList[0]'
              else
                echo "::warning::Timeout waiting for instance $INSTANCE_ID (could not retrieve final status)"
              fi
            fi
          done

      - name: Check Command Status and Display Output
        run: |
          COMMAND_ID="${{ steps.execute_command.outputs.command_id }}"
          FAILED_INSTANCES=0
          
          echo "Checking command status for all instances..."
          IFS=',' read -ra IDS <<< "${{ steps.instance_lookup.outputs.instance_ids }}"
          for INSTANCE_ID in "${IDS[@]}"; do
            INVOCATION=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --output json 2>/dev/null)
            
            # Check if we got a response
            if [ -z "$INVOCATION" ]; then
              echo ""
              echo "=========================================="
              echo "Instance: $INSTANCE_ID"
              echo "Status: Error retrieving invocation"
              echo "=========================================="
              echo "Could not retrieve command invocation details (empty response)"
              FAILED_INSTANCES=$((FAILED_INSTANCES + 1))
              echo ""
              continue
            fi
            
            # Check if this is an AWS API error response (has __type field)
            if echo "$INVOCATION" | jq -e '.__type' > /dev/null 2>&1; then
              ERROR_TYPE=$(echo "$INVOCATION" | jq -r '.__type // "Unknown"')
              ERROR_MSG=$(echo "$INVOCATION" | jq -r '.message // .Message // "Unknown error"')
              echo ""
              echo "=========================================="
              echo "Instance: $INSTANCE_ID"
              echo "Status: Error retrieving invocation"
              echo "=========================================="
              echo "AWS API Error: $ERROR_TYPE"
              echo "Error Message: $ERROR_MSG"
              FAILED_INSTANCES=$((FAILED_INSTANCES + 1))
              echo ""
              continue
            fi
            
            STATUS=$(echo "$INVOCATION" | jq -r '.Status' 2>/dev/null || echo "Unknown")
            STATUS_DETAILS=$(echo "$INVOCATION" | jq -r '.StatusDetails // "N/A"' 2>/dev/null)
            RESPONSE_CODE=$(echo "$INVOCATION" | jq -r '.ResponseCode // "N/A"' 2>/dev/null)
            EXECUTION_ELAPSED=$(echo "$INVOCATION" | jq -r '.ExecutionElapsedTime // "N/A"' 2>/dev/null)
            STANDARD_OUTPUT=$(echo "$INVOCATION" | jq -r '.StandardOutputContent // ""' 2>/dev/null)
            STANDARD_ERROR=$(echo "$INVOCATION" | jq -r '.StandardErrorContent // ""' 2>/dev/null)
            
            echo ""
            echo "=========================================="
            echo "Instance: $INSTANCE_ID"
            echo "Status: $STATUS"
            echo "Status Details: $STATUS_DETAILS"
            echo "Response Code: $RESPONSE_CODE"
            echo "Execution Time: ${EXECUTION_ELAPSED}ms"
            echo "=========================================="
            
            if [ "$STATUS" = "Success" ]; then
              echo "--- Standard Output ---"
              if [ -n "$STANDARD_OUTPUT" ] && [ "$STANDARD_OUTPUT" != "null" ]; then
                echo "$STANDARD_OUTPUT"
              else
                echo "(No output)"
              fi
            else
              echo "::error::Command failed on instance $INSTANCE_ID with status: $STATUS"
              if [ "$STATUS_DETAILS" != "N/A" ] && [ "$STATUS_DETAILS" != "null" ]; then
                echo "Status Details: $STATUS_DETAILS"
              fi
              FAILED_INSTANCES=$((FAILED_INSTANCES + 1))
              
              echo "--- Standard Output ---"
              if [ -n "$STANDARD_OUTPUT" ] && [ "$STANDARD_OUTPUT" != "null" ]; then
                echo "$STANDARD_OUTPUT"
              else
                echo "(No output)"
              fi
              
              echo "--- Standard Error ---"
              if [ -n "$STANDARD_ERROR" ] && [ "$STANDARD_ERROR" != "null" ]; then
                echo "$STANDARD_ERROR"
              else
                echo "(No error output)"
              fi
              
              # Show full invocation for debugging
              if [ "$STATUS" = "Pending" ]; then
                echo "--- Full Invocation Details (for debugging) ---"
                echo "$INVOCATION" | jq '.'
              fi
            fi
            echo ""
          done
          
          if [ $FAILED_INSTANCES -gt 0 ]; then
            echo "::error::Command failed on $FAILED_INSTANCES instance(s)"
            exit 1
          else
            echo "✓ Command completed successfully on all instances"
          fi

